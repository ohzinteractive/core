import type { Camera, Points } from 'three';
import { PlaneHelper, Quaternion, Vector3 } from 'three';
import { Plane } from 'three';
import { Box3 } from 'three';
import type { Input } from '../lib/Input';
import type { Cube } from '../primitives/Cube';
import type { Sphere } from '../primitives/Sphere';
import type { CameraMovementMode } from './movement_mode/CameraMovementMode';
import { AbstractCameraState } from './states/common/AbstractCameraState';
export declare class CameraController {
    __last_reference_position: Vector3;
    camera: Camera;
    camera_initial_pos: Vector3;
    camera_initial_rot: Quaternion;
    current_azimuth: number;
    current_mode: CameraMovementMode;
    current_orientation: number;
    current_state: AbstractCameraState;
    current_tilt: number;
    debug_box: Cube;
    input: Input;
    input_enabled: boolean;
    max_zoom: number;
    min_zoom: number;
    normalized_zoom: number;
    old_orientation: number;
    orientation: number;
    point_of_interest: Vector3;
    projected_points: Points[];
    projection_plane_helper: PlaneHelper;
    projection_sphere_helper: Sphere;
    raised_look_at_position: Vector3;
    reference_position: Vector3;
    reference_rotation: Quaternion;
    reference_zoom: number;
    tilt: number;
    tmp_dir: Vector3;
    tmp_forward: Vector3;
    tmp_quat: Quaternion;
    tmp_right: Vector3;
    tmp_size: Vector3;
    use_raised_look_at_direction: number;
    vector_forward_axis: Vector3;
    vector_right_axis: Vector3;
    vector_up_axis: Vector3;
    zoom: number;
    constructor(input: Input);
    enable(): void;
    disable(): void;
    set_camera(camera: Camera): void;
    set_state(state: AbstractCameraState): void;
    set_mode(mode: CameraMovementMode): void;
    set_normalized_zoom(zoom: number): void;
    update_normalized_zoom(min_zoom: number, max_zoom: number): void;
    update(): void;
    set_idle(): void;
    camera_is_zoomed_out(): boolean;
    set_rotation(tilt: number, orientation: number, azimuth?: number): void;
    set_rotation_delta(tilt: number, orientation: number, azimuth?: number): void;
    lerp_tilt(from_tilt: number, to_tilt: number, t: number): void;
    set_quaternion(q: Quaternion): void;
    lerp_quaternion(q: Quaternion, t: number): void;
    lerp_orientation(from_orientation: number, to_orientation: number, t: number): void;
    lerp_azimuth(from_azimuth: number, to_azimuth: number, t: number): void;
    lerp_rotation(from_tilt: number, to_tilt: number, from_orientation: number, to_orientation: number, from_azimuth: number, to_azimuth: number, t: number): void;
    build_rotation(tilt: number, orientation: number): Quaternion;
    translate_forward(amount: number): void;
    translate_right(amount: number): void;
    focus_on_bounding_box(bb: Box3, scale?: number): void;
    get_zoom_to_focus_on_points(points: Vector3[], scale: number): number;
    get_target_pos_to_focus_on_points(points: Vector3[], scale: number): Vector3;
    focus_camera_on_sphere(sphere: Sphere, debug: boolean): void;
    get_zoom_to_sphere(sphere: Sphere, debug: boolean): number;
    hide_projected_points(): void;
    show_projected_points(points: Vector3[]): void;
    show_plane_projection(plane: Plane, size?: number): void;
    show_sphere_projection(sphere: Sphere): void;
    fit_points(quaternion: Quaternion, points: Vector3[], zoom_scale?: number): {
        zoom: number;
        reference_position: Vector3;
        camera_position: Vector3;
    };
    focus_camera_on_points(points: Vector3[], zoom_scale?: number): void;
    get_current_tilt(): number;
    get_current_orientation(): number;
    get_current_azimuth(): number;
    __get_zoom_to_show_rect(width: number, height: number, scale?: number): number;
}
